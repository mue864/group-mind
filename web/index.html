<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GroupMind - Web Call</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10;
      }

      .status {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ff9800;
      }

      .status-indicator.connected {
        background: #4caf50;
      }

      .video-container {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 10px;
        padding: 20px;
        position: relative;
      }

      .video-wrapper {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        background: #333;
        aspect-ratio: 16/9;
      }

      .video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-overlay {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .participant-name {
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
      }

      .muted-indicator {
        background: rgba(255, 0, 0, 0.8);
        padding: 4px;
        border-radius: 50%;
      }

      .local-video {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 200px;
        height: 150px;
        border-radius: 12px;
        overflow: hidden;
        border: 2px solid #fff;
        z-index: 5;
      }

      .controls {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 20px;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        gap: 20px;
      }

      .control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        background: #fff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        transition: all 0.2s;
      }

      .control-btn:hover {
        transform: scale(1.1);
      }

      .control-btn.active {
        background: #ff4444;
        color: #fff;
      }

      .control-btn.end-call {
        background: #ff4444;
        color: #fff;
      }

      .join-form {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        color: #000;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
        min-width: 300px;
      }

      .join-form input {
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
      }

      .join-form button {
        width: 100%;
        padding: 12px;
        background: #4169e1;
        color: #fff;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        margin-top: 10px;
      }

      .join-form button:hover {
        background: #3151b1;
      }

      .hidden {
        display: none;
      }

      .waiting {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        gap: 20px;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #333;
        border-top: 4px solid #4169e1;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Join Form -->
      <div id="joinForm" class="join-form">
        <h2>Join Group Call</h2>
        <input type="text" id="roomId" placeholder="Enter Group ID" />
        <input type="text" id="userName" placeholder="Enter your name" />
        <select id="callType">
          <option value="video">Video Call</option>
          <option value="audio">Audio Call</option>
        </select>
        <button onclick="joinCall()">Join Call</button>
      </div>

      <!-- Call Interface -->
      <div id="callInterface" class="hidden">
        <!-- Header -->
        <div class="header">
          <div class="status">
            <div id="statusIndicator" class="status-indicator"></div>
            <span id="statusText">Connecting...</span>
          </div>
          <div id="participantCount">0/4</div>
        </div>

        <!-- Video Container -->
        <div class="video-container">
          <div id="waitingMessage" class="waiting">
            <div class="spinner"></div>
            <p>Waiting for others to join...</p>
          </div>
          <div id="remoteVideos"></div>
          <div id="localVideo" class="local-video hidden">
            <video id="localVideoElement" class="video" autoplay muted></video>
            <div class="video-overlay">
              <span class="participant-name">You</span>
              <div id="localMutedIndicator" class="muted-indicator hidden">
                ðŸ”‡
              </div>
            </div>
          </div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <button id="muteBtn" class="control-btn" onclick="toggleMute()">
            ðŸŽ¤
          </button>
          <button id="videoBtn" class="control-btn" onclick="toggleVideo()">
            ðŸ“¹
          </button>
          <button
            id="switchCameraBtn"
            class="control-btn"
            onclick="switchCamera()"
          >
            ðŸ”„
          </button>
          <button
            id="endCallBtn"
            class="control-btn end-call"
            onclick="endCall()"
          >
            ðŸ“ž
          </button>
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>

    <script>
      // Firebase configuration (replace with your config)
      const firebaseConfig = {
        apiKey: "AIzaSyAVTe0GFYJTqNWk43rjDIGV-0T6CPmE8dA",
        authDomain: "group-mind.firebaseapp.com",
        projectId: "group-mind",
        storageBucket: "group-mind.firebasestorage.app",
        messagingSenderId: "132683689333",
        databaseURL: "https://group-mind-default-rtdb.firebaseio.com",
        appId: "1:132683689333:web:869db8d46e0f3cfed2373c",
        measurementId: "G-DQL2S9MZT5",
      };

      // Initialize Firebase
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();

      // WebRTC variables
      let localStream = null;
      let peerConnections = new Map();
      let roomId = "";
      let userId = "";
      let userName = "";
      let callType = "video";
      let isMuted = false;
      let isVideoOff = false;

      // RTC Configuration
      const rtcConfig = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
        ],
      };

      async function joinCall() {
        roomId = document.getElementById("roomId").value;
        userName = document.getElementById("userName").value;
        callType = document.getElementById("callType").value;

        if (!roomId || !userName) {
          alert("Please enter room ID and your name");
          return;
        }

        userId =
          "web_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);

        try {
          // Get user media
          const constraints = {
            audio: true,
            video:
              callType === "video"
                ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                  }
                : false,
          };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);

          // Show local video
          const localVideoElement =
            document.getElementById("localVideoElement");
          localVideoElement.srcObject = localStream;
          document.getElementById("localVideo").classList.remove("hidden");

          // Hide join form and show call interface
          document.getElementById("joinForm").classList.add("hidden");
          document.getElementById("callInterface").classList.remove("hidden");

          // Join room
          await joinRoom();

          // Listen for participants
          listenForParticipants();

          // Listen for offers
          listenForOffers();

          // Listen for ICE candidates
          listenForIceCandidates();
        } catch (error) {
          console.error("Error accessing media devices:", error);
          alert(
            "Failed to access camera/microphone. Please check permissions."
          );
        }
      }

      async function joinRoom() {
        const participantRef = db
          .collection("calls")
          .doc(roomId)
          .collection("participants")
          .doc(userId);
        await participantRef.set({
          id: userId,
          name: userName,
          isAdmin: false,
          isMod: false,
          isMuted: false,
          isVideoOff: callType === "audio",
          joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
          callType: callType,
          platform: "web",
          lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
        });
      }

      function listenForParticipants() {
        const participantsRef = db.collection('calls').doc(roomId).collection('participants');
        participantsRef.onSnapshot(async (snapshot) => {
          const participants = [];
          
          snapshot.forEach((doc) => {
            const data = doc.data();
            // Only include participants who have been active in the last 30 seconds
            const lastSeen = data.lastSeen?.toDate?.() || new Date(0);
            const thirtySecondsAgo = new Date(Date.now() - 30000);
            
            if (lastSeen > thirtySecondsAgo) {
              participants.push({
                id: data.id,
                name: data.name,
                isAdmin: data.isAdmin || false,
                isMod: data.isMod || false,
                isMuted: data.isMuted || false,
                isVideoOff: data.isVideoOff || false,
              });
            }
          });
          
          updateParticipantCount(participants.length);
          
          // Handle new participants
          for (const participant of participants) {
            if (
              participant.id !== userId &&
              !peerConnections.has(participant.id)
            ) {
              await createPeerConnection(participant.id);
            }
          }

          // Handle disconnected participants
          const currentParticipantIds = participants.map((p) => p.id);
          for (const [peerId, pc] of peerConnections) {
            if (!currentParticipantIds.includes(peerId)) {
              removePeerConnection(peerId);
            }
          }

          updateStatus(participants.length > 1);
        });
      }

      async function createPeerConnection(peerId) {
        const pc = new RTCPeerConnection(rtcConfig);
        peerConnections.set(peerId, pc);

        // Add local stream tracks
        if (localStream) {
          localStream.getTracks().forEach((track) => {
            pc.addTrack(track, localStream);
          });
        }

        // Handle incoming tracks
        pc.ontrack = (event) => {
          addRemoteVideo(peerId, event.streams[0]);
        };

        // Handle ICE candidates
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            sendIceCandidate(peerId, event.candidate);
          }
        };

        // Create and send offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendOffer(peerId, offer);
      }

      async function sendOffer(peerId, offer) {
        const offerRef = database.ref(
          `calls/${roomId}/signals/${userId}_${peerId}/offer`
        );
        await offerRef.set({
          sdp: offer.sdp,
          type: offer.type,
          timestamp: Date.now(),
        });
      }

      function listenForOffers() {
        const signalsRef = database.ref(`calls/${roomId}/signals`);
        signalsRef.on("value", async (snapshot) => {
          const signalsData = snapshot.val();
          if (!signalsData) return;

          for (const [signalId, signalData] of Object.entries(signalsData)) {
            if (signalId.includes(`_${userId}`) && signalData.offer) {
              const peerId = signalId.split("_")[0];
              await handleOffer(peerId, signalData.offer);
            }
          }
        });
      }

      async function handleOffer(peerId, offerData) {
        let pc = peerConnections.get(peerId);

        if (!pc) {
          pc = new RTCPeerConnection(rtcConfig);
          peerConnections.set(peerId, pc);

          // Add local stream tracks
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              pc.addTrack(track, localStream);
            });
          }

          // Handle incoming tracks
          pc.ontrack = (event) => {
            addRemoteVideo(peerId, event.streams[0]);
          };

          // Handle ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              sendIceCandidate(peerId, event.candidate);
            }
          };
        }

        // Set remote description and create answer
        await pc.setRemoteDescription(new RTCSessionDescription(offerData));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        // Send answer
        await sendAnswer(peerId, answer);

        // Clean up offer
        const offerRef = database.ref(
          `calls/${roomId}/signals/${peerId}_${userId}/offer`
        );
        offerRef.remove();
      }

      async function sendAnswer(peerId, answer) {
        const answerRef = database.ref(
          `calls/${roomId}/signals/${userId}_${peerId}/answer`
        );
        await answerRef.set({
          sdp: answer.sdp,
          type: answer.type,
          timestamp: Date.now(),
        });
      }

      async function sendIceCandidate(peerId, candidate) {
        const candidateRef = database.ref(
          `calls/${roomId}/signals/${userId}_${peerId}/ice`
        );
        await candidateRef.push({
          candidate: candidate.candidate,
          sdpMLineIndex: candidate.sdpMLineIndex,
          sdpMid: candidate.sdpMid,
          timestamp: Date.now(),
        });
      }

      function listenForIceCandidates() {
        const signalsRef = database.ref(`calls/${roomId}/signals`);
        signalsRef.on("value", async (snapshot) => {
          const signalsData = snapshot.val();
          if (!signalsData) return;

          for (const [signalId, signalData] of Object.entries(signalsData)) {
            if (signalId.includes(`_${userId}`) && signalData.ice) {
              const peerId = signalId.split("_")[0];
              const pc = peerConnections.get(peerId);

              if (pc && signalData.ice) {
                for (const candidateData of Object.values(signalData.ice)) {
                  await pc.addIceCandidate(new RTCIceCandidate(candidateData));
                }
              }
            }
          }
        });
      }

      function addRemoteVideo(peerId, stream) {
        const remoteVideos = document.getElementById("remoteVideos");
        const waitingMessage = document.getElementById("waitingMessage");

        if (waitingMessage) {
          waitingMessage.classList.add("hidden");
        }

        // Check if video element already exists
        let videoElement = document.getElementById(`video-${peerId}`);
        if (!videoElement) {
          const videoWrapper = document.createElement("div");
          videoWrapper.className = "video-wrapper";
          videoWrapper.id = `wrapper-${peerId}`;

          videoElement = document.createElement("video");
          videoElement.id = `video-${peerId}`;
          videoElement.className = "video";
          videoElement.autoplay = true;
          videoElement.playsInline = true;

          const overlay = document.createElement("div");
          overlay.className = "video-overlay";
          overlay.innerHTML = `
                    <span class="participant-name">Participant</span>
                    <div class="muted-indicator hidden">ðŸ”‡</div>
                `;

          videoWrapper.appendChild(videoElement);
          videoWrapper.appendChild(overlay);
          remoteVideos.appendChild(videoWrapper);
        }

        videoElement.srcObject = stream;
      }

      function removePeerConnection(peerId) {
        const pc = peerConnections.get(peerId);
        if (pc) {
          pc.close();
          peerConnections.delete(peerId);
        }

        // Remove video element
        const videoWrapper = document.getElementById(`wrapper-${peerId}`);
        if (videoWrapper) {
          videoWrapper.remove();
        }

        // Show waiting message if no remote videos
        const remoteVideos = document.getElementById("remoteVideos");
        if (remoteVideos.children.length === 0) {
          document.getElementById("waitingMessage").classList.remove("hidden");
        }
      }

      function updateParticipantCount(count) {
        document.getElementById("participantCount").textContent = `${count}/4`;
      }

      function updateStatus(connected) {
        const statusIndicator = document.getElementById("statusIndicator");
        const statusText = document.getElementById("statusText");

        if (connected) {
          statusIndicator.classList.add("connected");
          statusText.textContent = "Connected";
        } else {
          statusIndicator.classList.remove("connected");
          statusText.textContent = "Connecting...";
        }
      }

      async function toggleMute() {
        if (!localStream) return;

        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;

          const muteBtn = document.getElementById("muteBtn");
          const localMutedIndicator = document.getElementById(
            "localMutedIndicator"
          );

          if (isMuted) {
            muteBtn.textContent = "ðŸ”‡";
            muteBtn.classList.add("active");
            localMutedIndicator.classList.remove("hidden");
          } else {
            muteBtn.textContent = "ðŸŽ¤";
            muteBtn.classList.remove("active");
            localMutedIndicator.classList.add("hidden");
          }

          // Update participant status
          await updateParticipantStatus({ isMuted });
        }
      }

      async function toggleVideo() {
        if (!localStream || callType === "audio") return;

        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          isVideoOff = !videoTrack.enabled;

          const videoBtn = document.getElementById("videoBtn");
          const localVideo = document.getElementById("localVideo");

          if (isVideoOff) {
            videoBtn.textContent = "ðŸ“¹";
            videoBtn.classList.add("active");
            localVideo.classList.add("hidden");
          } else {
            videoBtn.textContent = "ðŸ“¹";
            videoBtn.classList.remove("active");
            localVideo.classList.remove("hidden");
          }

          // Update participant status
          await updateParticipantStatus({ isVideoOff });
        }
      }

      async function switchCamera() {
        if (!localStream || callType === "audio") return;

        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack && videoTrack.getCapabilities) {
          const capabilities = videoTrack.getCapabilities();
          if (capabilities.facingMode) {
            const facingMode = capabilities.facingMode.includes("user")
              ? "environment"
              : "user";
            await videoTrack.applyConstraints({
              advanced: [{ facingMode }],
            });
          }
        }
      }

      async function updateParticipantStatus(updates) {
        const participantRef = database.ref(
          `calls/${roomId}/participants/${userId}`
        );
        await participantRef.update(updates);
      }

      async function endCall() {
        if (confirm("Are you sure you want to end the call?")) {
          // Close all peer connections
          for (const [peerId, pc] of peerConnections) {
            pc.close();
          }
          peerConnections.clear();

          // Stop local stream
          if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            localStream = null;
          }

          // Remove from room
          const participantRef = database.ref(
            `calls/${roomId}/participants/${userId}`
          );
          await participantRef.remove();

          // Clean up listeners
          const participantsRef = database.ref(`calls/${roomId}/participants`);
          participantsRef.off();

          const signalsRef = database.ref(`calls/${roomId}/signals`);
          signalsRef.off();

          // Show join form again
          document.getElementById("callInterface").classList.add("hidden");
          document.getElementById("joinForm").classList.remove("hidden");

          // Reset form
          document.getElementById("roomId").value = "";
          document.getElementById("userName").value = "";
          document.getElementById("callType").value = "video";
        }
      }

      // Handle page unload
      window.addEventListener("beforeunload", () => {
        if (localStream) {
          endCall();
        }
      });
    </script>
  </body>
</html>
